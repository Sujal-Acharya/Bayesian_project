# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jYKfXJTG5-cRCHBFGm0h0us5jCZZG9ZK
"""

import streamlit as st
import pandas as pd
import numpy as np
import random
import plotly.express as px
import plotly.graph_objects as go

st.set_page_config(page_title="Dynamic Pricing Optimization", layout="wide")

# ==============================
# Bandit Algorithms
# ==============================

class EpsilonGreedy:
    def __init__(self, n_arms, epsilon=0.1):
        self.n_arms = n_arms
        self.epsilon = epsilon
        self.counts = np.zeros(n_arms)
        self.values = np.zeros(n_arms)

    def select_arm(self):
        if random.random() < self.epsilon:
            return np.random.randint(self.n_arms)
        return np.argmax(self.values)

    def update(self, arm, reward):
        self.counts[arm] += 1
        n = self.counts[arm]
        self.values[arm] += (reward - self.values[arm]) / n


class UCB:
    def __init__(self, n_arms):
        self.n_arms = n_arms
        self.counts = np.zeros(n_arms)
        self.values = np.zeros(n_arms)
        self.total_count = 0

    def select_arm(self):
        self.total_count += 1
        for arm in range(self.n_arms):
            if self.counts[arm] == 0:
                return arm

        ucb_values = self.values + np.sqrt((2 * np.log(self.total_count)) / self.counts)
        return np.argmax(ucb_values)

    def update(self, arm, reward):
        self.counts[arm] += 1
        n = self.counts[arm]
        self.values[arm] += (reward - self.values[arm]) / n


class ThompsonSampling:
    def __init__(self, n_arms):
        self.success = np.ones(n_arms)
        self.failure = np.ones(n_arms)

    def select_arm(self):
        samples = np.random.beta(self.success, self.failure)
        return np.argmax(samples)

    def update(self, arm, reward):
        if reward == 1:
            self.success[arm] += 1
        else:
            self.failure[arm] += 1


# ==============================
# Experiment Function
# ==============================

def run_experiment(df, bandit, prices):
    cumulative_rev = []
    total_rev = 0

    for _, row in df.iterrows():
        arm = bandit.select_arm()
        price = prices[arm]
        reward = row["Purchased"]

        bandit.update(arm, reward)
        total_rev += reward * price
        cumulative_rev.append(total_rev)

    return cumulative_rev, total_rev


# ==============================
# Streamlit UI
# ==============================

st.title("ðŸ’° Dynamic Pricing Optimization Using Multi-Armed Bandits")
st.write("Optimize revenue with Epsilon-Greedy, UCB, and Thompson Sampling algorithms.")

uploaded_file = st.file_uploader("/content/dynamic_pricing.csv", type=["csv"])

if uploaded_file:
    df = pd.read_csv(uploaded_file)

    industry_list = sorted(df["Industry"].unique())
    industry = st.selectbox("Select Industry", industry_list)

    investment = st.number_input("Enter Investment Amount (â‚¹)", min_value=1000, value=100000)

    df_ind = df[df["Industry"] == industry]
    prices = sorted(df_ind["Price"].unique())

    if st.button("Run Optimization"):
        eg = EpsilonGreedy(len(prices))
        ucb = UCB(len(prices))
        ts = ThompsonSampling(len(prices))

        eg_curve, eg_rev = run_experiment(df_ind, eg, prices)
        ucb_curve, ucb_rev = run_experiment(df_ind, ucb, prices)
        ts_curve, ts_rev = run_experiment(df_ind, ts, prices)

        # ROI Table
        results = pd.DataFrame({
            "Algorithm": ["Epsilon-Greedy", "UCB", "Thompson Sampling"],
            "Revenue (â‚¹)": [eg_rev, ucb_rev, ts_rev],
            "Profit (â‚¹)": [eg_rev - investment, ucb_rev - investment, ts_rev - investment],
            "ROI (%)": [
                ((eg_rev - investment) / investment) * 100,
                ((ucb_rev - investment) / investment) * 100,
                ((ts_rev - investment) / investment) * 100,
            ]
        })

        st.subheader("ðŸ“Š ROI Comparison Table")
        st.dataframe(results)

        # Cumulative Revenue Graph
        fig = go.Figure()
        fig.add_trace(go.Scatter(y=eg_curve, name="Epsilon-Greedy"))
        fig.add_trace(go.Scatter(y=ucb_curve, name="UCB"))
        fig.add_trace(go.Scatter(y=ts_curve, name="Thompson Sampling"))
        fig.update_layout(title="Cumulative Revenue Comparison", xaxis_title="Iterations", yaxis_title="Revenue (â‚¹)")
        st.plotly_chart(fig, use_container_width=True)

        # ROI Bar Graph
        fig2 = px.bar(results, x="Algorithm", y="ROI (%)", color="Algorithm",
                      title="ROI (%) Comparison", text="ROI (%)")
        fig2.update_traces(texttemplate='%{text:.2f}', textposition='outside')
        st.plotly_chart(fig2, use_container_width=True)



        st.success("Optimization completed! Scroll to see all visualizations.")